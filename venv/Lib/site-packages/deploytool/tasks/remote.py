import os
import sys
import uuid
import warnings

from fabric.api import abort, env, hide, settings
from fabric.colors import green, magenta, red, yellow
from fabric.contrib import django
from fabric.contrib.console import confirm
from fabric.contrib.files import exists
from fabric.operations import local, open_shell, put, require, run
from fabric.tasks import Task

from deploytool import utils
from deploytool.utils import commands
from deploytool.utils.deploy import WebsiteDeployment
from deploytool.utils.instance import backup_and_download_database, ls


class RemoteHost(Task):
    """ HOST """

    requirements = [
        'environment',
        'hosts',
        'project_name',
        'project_name_prefix',
        'vhosts_path',
    ]

    def __init__(self, *args, **kwargs):
        super(RemoteHost, self).__init__(*args, **kwargs)

        # use environment as task name
        self.name = kwargs['settings']['environment']

        # save project settings in instance
        self.settings = kwargs['settings']

        if 'use_syncdb' not in self.settings:
            warnings.warn(
                'syncdb has been deprecated since Django 1.7 and the deploytool will NOT use it by default.'
                ' Please set use_syncdb=False|True in your RemoteHost settings to hide this warning.',
                DeprecationWarning, stacklevel=2)

        if 'python_version' not in self.settings:
            warnings.warn(
                'Defaulting to python2.7. Please set a python_version in your RemoteHost settings'
                ' (e.g. python2.7 or python3.4) to hide this warning.',
                DeprecationWarning, stacklevel=2)

    def run(self):

        # update fabric environment for project settings
        env.update(self.settings)
        env.setdefault('python_version', 'python2.7')
        env.setdefault('compass_version', None)
        env.setdefault('use_syncdb', False)
        env.setdefault('project_path_name', env.project_name)

        # check if all required project settings are present in fabric environment
        [require(r) for r in self.requirements]

        vhost_folder = '%s%s' % (env.project_name_prefix, env.project_name)
        vhost_path = os.path.join(env.vhosts_path, vhost_folder)

        print(green('\nInitializing fabric environment for %s.' % magenta(self.name)))

        # project_name:           example
        # project_name_prefix:    t-
        # user:                   t-example
        # project_path_name:      example

        # vhosts_path:            /var/www/vhosts/
        # vhost_path:             /var/www/vhosts/t-example/
        # current_instance_path:  /var/www/vhosts/t-example/current_instance/
        # previous_instance_path: /var/www/vhosts/t-example/previous_instance/
        # log_path:               /var/www/vhosts/t-example/log/
        # media_path:             /var/www/vhosts/t-example/media/
        # supervisor_path:        /var/www/vhosts/t-example/supervisor

        env.update({
            'database_name': env.project_name,
            'vhost_path': vhost_path,
            'current_instance_path': os.path.join(vhost_path, 'current_instance'),
            'log_path': os.path.join(vhost_path, 'log'),
            'media_path': os.path.join(vhost_path, 'media'),
            'previous_instance_path': os.path.join(vhost_path, 'previous_instance'),
            'user': '%s%s' % (env.project_name_prefix, env.project_name),
            'supervisor_path': os.path.join(vhost_path, 'supervisor'),
        })


class RemoteTask(Task):
    """
    Base class for remote tasks
        - updates fabric env for instance
        - handles logging
    """

    requirements = [
        'vhost_path',
        'project_name',
    ]

    def __call__(self, *args, **kwargs):
        """ Task implementation - called from self.run() """

        raise NotImplementedError

    def log(self, success):
        utils.instance.log(success, task_name=self.name, stamp=self.stamp, log_path=env.log_path)

    def run(self, *args, **kwargs):
        """ Hide output, update fabric env, run task """

        # hide fabric output
        if 'debug' in args:
            hidden_groups = ('running',)
        else:
            hidden_groups = ('running', 'stdout')

        with settings(hide(*hidden_groups)):

            # check if HOST task was run before this task
            if not hasattr(env, 'current_instance_path'):
                message = str.join(' ', [
                    red('\nRun a HOST task before running this remote task (e.g. `fab staging deploy`).\n'),
                    'Use `fab -l` to see a list of all available tasks.\n',
                    'Use `fab -d %s` to see this task\'s details.\n' % self.name,
                ])
                abort(message)

            # load current instance unless task already provided something else
            if not hasattr(self, 'stamp'):
                self.stamp = utils.instance.get_instance_stamp(env.current_instance_path)

            # check if all required HOST settings are present in fabric environment
            [require(r) for r in self.requirements]

            # update fabric environment for instance settings
            # instance_path is the path of current instance; it's not the symbolic link
            instance_path = utils.commands.read_link(env.current_instance_path)

            full_project_name = '%s%s' % (env.project_name_prefix, env.project_name)

            # instance_stamp:       [sha1]

            # instance_path:        /var/www/vhosts/t-example/[sha1]/
            # backup_path:          /var/www/vhosts/t-example/[sha1]/backup/
            # source_path:          /var/www/vhosts/t-example/[sha1]/t-example/
            # project_path:         /var/www/vhosts/t-example/[sha1]/t-example/
            # project_project_path: /var/www/vhosts/t-example/[sha1]/t-example/example/
            # virtualenv_path:      /var/www/vhosts/t-example/[sha1]/env/

            env.update({
                'backup_path': os.path.join(instance_path, 'backup'),
                'instance_stamp': self.stamp,
                'instance_path': instance_path,
                'source_path': os.path.join(instance_path, full_project_name),
                'project_path': os.path.join(instance_path, full_project_name),
                'project_project_path': os.path.join(instance_path, full_project_name, env.project_path_name),
                'virtualenv_path': os.path.join(instance_path, 'env'),
            })

            # finally, run the task implementation!
            self(*args, **kwargs)


class Deployment(RemoteTask):
    """
    REMO - Deploy new instance

        Usage:

        # deployment using current git HEAD
        $ fab staging deploy
    """

    name = 'deploy'

    def run(self, *args, **kwargs):
        """
        Load instance from CLI kwargs

            deploy by HEAD for current branch
        """

        with settings(hide('warnings', 'running', 'stdout', 'stderr')):

            # check if remote stamp exists in local repo
            current_instance = utils.commands.read_link(env.current_instance_path)
            remote_stamp = utils.instance.get_instance_stamp(current_instance)

            if remote_stamp:
                if '/' in remote_stamp:
                    # first deploy to remote
                    print(green('\nFirst deploy to remote.'))
                elif utils.commands.remote_stamp_in_local_repo(remote_stamp):
                    # show changed files with `diff` command
                    Diff().run()
                else:
                    # deployed commit is not in your local repository
                    print(red('\nWarning: deployed commit is not in your local repository.'))

            # ask to deploy
            self.stamp = utils.source.get_head()
            _args = (utils.source.get_branch_name(), self.stamp)

            question = '\nDeploy branch %s at commit %s?' % _args

            if 'non_interactive' not in args:
                if not confirm(yellow(question)):
                    abort(red('Aborted deployment. Run `fab -d %s` for options.' % self.name))

        super(Deployment, self).run(*args, **kwargs)

    def __call__(self, *args, **kwargs):
        use_force = 'force' in args
        # Remove the next few lines in a future version.
        skip_syncdb = 'skip_syncdb' in args
        if skip_syncdb:
            print(yellow('skip_syncdb has been renamed to skip_migrate and will be removed in a future version.'))
        # Also remove the "skip_syncdb or" part of the next statement.
        skip_migrate = skip_syncdb or 'skip_migrate' in args

        # check if deploy is possible
        if not use_force:
            if self.stamp == utils.instance.get_instance_stamp(env.current_instance_path):
                question = 'Warning: %s already is the current instance, deploy anyway?' % self.stamp
                if 'non_interactive' in args or not confirm(yellow(question), default=False):
                    abort(red('Deploy aborted because %s already is the current instance.' % self.stamp))
            elif self.stamp == utils.instance.get_instance_stamp(env.previous_instance_path):
                abort(red('Deploy aborted because %s is the previous instance. Use rollback task instead.' % self.stamp))
            elif exists(os.path.join(env.vhost_path, self.stamp)):
                abort(red('Deploy aborted because instance %s has already been deployed.' % self.stamp))

        # Parse optional 'pause' argument, can be given like this:
        # fab staging deploy:pause=before_migrate
        pause_at = kwargs['pause'].split(',') if ('pause' in kwargs) else []

        website = WebsiteDeployment(
            vhost_path=env.vhost_path,
            project_name=env.project_name,
            project_name_prefix=env.project_name_prefix,
            project_settings_directory=env.project_path_name,
            stamp=self.stamp,
            pause_at=pause_at,
            skip_migrate=skip_migrate,
            restart_services=env.get('restart_services', None),
            python_version=env.python_version,
            task_args=args,
            task_kwargs=kwargs,
        )
        website.deploy()


class RemoveOldInstances(RemoteTask):
    """ REMO - Remove old instances """
    name = 'remove_old_instances'

    def __call__(self, *args, **kwargs):
        utils.instance.prune_obsolete_instances(env.vhost_path)


class Rollback(RemoteTask):
    """ REMO - Rollback current instance to previous instance """

    name = 'rollback'

    def __call__(self, *args, **kwargs):

        # check if rollback is possible
        if not exists(env.previous_instance_path):
            abort(red('No rollback possible. No previous instance found to rollback to.'))

        # Find gziped or plain db_backup file (for backwards compatibility)
        for db_backup_file in ('db_backup_start.sql.gz', 'db_backup_start.sql'):
            db_backup_path = os.path.join(env.backup_path, db_backup_file)
            if exists(db_backup_path):
                break
        else:
            db_backup_path = None

        if db_backup_path is None:
            abort(red('Could not find backupfile to restore database with.'))

        # start rollback
        is_website_running = True
        try:
            print(green('\nStopping website'))
            commands.stop_supervisor_jobs(env.vhost_path)
            is_website_running = False

            print(green('\nRestoring database to start of this instance.'))
            utils.instance.restore_database(db_backup_path)

            print(green('\nRemoving this instance and set previous to current.'))
            utils.instance.rollback(env.vhost_path)

            print(green('\nStarting website.'))
            commands.start_supervisor_jobs(env.vhost_path)
            is_website_running = True

            print(green('\nRemoving this instance from filesystem.'))
            utils.commands.delete(env.instance_path)

            self.log(success=True)

        except Exception as e:
            if not is_website_running:
                commands.start_supervisor_jobs(env.vhost_path)

            self.log(success=False)
            abort(red('Rollback failed: %s ' % e.message))


class Status(RemoteTask):
    """ REMO - Show status information for remote host """

    name = 'status'

    def __call__(self, *args, **kwargs):

        print(green('\nCurrent instance:'))
        current_instance = utils.commands.read_link(env.current_instance_path)
        if current_instance != env.current_instance_path:
            print(current_instance)
        else:
            print(red('[none]'))

        print(green('\nPrevious instance:'))
        previous_instance = utils.commands.read_link(env.previous_instance_path)
        if previous_instance != env.previous_instance_path:
            print(previous_instance)
        else:
            print(red('[none]'))

        print(green('\nFabric log:'))
        if exists(os.path.join(env.log_path, 'fabric.log')):
            print(utils.commands.tail_file(os.path.join(env.log_path, 'fabric.log')))
        else:
            print(red('[empty]'))


class Size(RemoteTask):
    """ REMO - Show project size on remote host """

    name = 'size'

    def __call__(self, *args, **kwargs):

        print(green('\nCurrent size of entire project:'))
        print(utils.commands.get_folder_size(env.project_path))
        print(utils.commands.get_folder_size(env.media_path))


class Diff(RemoteTask):
    """ REMO - Show changed files with remote host

        Usage:

        $ fab staging diff

        # show full diff
        $ fab staging diff:full
    """

    name = 'diff'

    def __call__(self, *args, **kwargs):

        show_full_diff = False
        if 'full' in args:
            show_full_diff = True

        print(green('\nChanged files compared to remote host.'))
        print(utils.commands.get_changed_files(utils.source.get_head(), env.instance_stamp, show_full_diff))


class Media(RemoteTask):
    """ REMO - Download media files (as archive) """

    name = 'media'

    def __call__(self, *args, **kwargs):

        file_name = 'project_media.tar'
        cwd = os.getcwd()

        print(green('\nCompressing remote media folder.'))
        utils.commands.create_tarball(env.vhost_path, 'media', file_name)  # TODO: media_path?

        print(green('\nDownloading tarball.'))
        utils.commands.download_file(
            remote_path=os.path.join(env.vhost_path, file_name),
            local_path=os.path.join(cwd, file_name)
        )

        print(green('\nSaved media tarball to:'))
        print(os.path.join(cwd, file_name))


class Database(RemoteTask):
    """ REMO - Download database (as sqldump) """

    name = 'database'

    def __call__(self, output_filename=None):
        output_filename = backup_and_download_database(output_filename)

        print(green('\nSaved backup to:'))
        print(output_filename)


class RestoreDatabase(RemoteTask):
    """ REMO - Restore database """
    name = 'restore_database'

    def __call__(self):
        # Find gziped or plain db_backup file (for backwards compatibility)
        for db_backup_file in ('db_backup_start.sql.gz', 'db_backup_start.sql'):
            db_backup_path = os.path.join(env.backup_path, db_backup_file)
            if exists(db_backup_path):
                break
        else:
            db_backup_path = None

        if db_backup_path is None:
            abort(red('Could not find backupfile to restore database with.'))

        utils.instance.restore_database(db_backup_path)


class Test(RemoteTask):
    """ REMO - Test task for testing pauses and hooks """

    name = 'test'

    def __call__(self, *args, **kwargs):

        """
        parse optional 'pause' argument, can be given like this:

        fab staging test:pause=test
        """
        pause_at = kwargs['pause'].split(',') if ('pause' in kwargs) else []

        # test pause
        if 'test' in pause_at:
            print(green('\nOpening remote shell - test.'))
            open_shell()

        # test hook
        if 'test' in env:
            env.test(env, *args, **kwargs)


class Restart(RemoteTask):
    """
    REMO - Restart the site using supervisor.
    - Also call 'after_restart' hook.
    """
    name = 'restart'

    requirements = [
        'project_name',
        'project_name_prefix',
    ]

    def __call__(self, *args, **kwargs):
        print(green('\nRestarting Website.'))

        commands.restart_supervisor_jobs(env.vhost_path)

        if 'after_restart' in env:
            env.after_restart(env, *args, **kwargs)


class RestoreRemoteDatabase(RemoteTask):
    """ REMO - Restore remote database """
    name = 'restore_remote_database'

    def __call__(self, *args, **kwargs):
        settings = self.import_django_settings()

        self.check_database_engine(settings)
        local_zipped_backup_file = backup_and_download_database()

        print('Restoring database on local machine')
        database_name = settings.DATABASES['default']['NAME']
        database_user = settings.DATABASES['default']['USER']

        result = local('dropdb --if-exists %s' % database_name)

        if result.return_code != 0:
            print 'Could not remove local database'
        else:
            local('gunzip %s' % local_zipped_backup_file)
            local_backup_file = local_zipped_backup_file.replace('.gz', '')

            local('createdb %s --owner=%s --encoding=utf8' % (database_name, database_user))
            local('psql -d %s -f %s -q' % (database_name, local_backup_file))
            local('rm %s' % local_backup_file)

    def import_django_settings(self):
        sys.path.append(os.getcwd())

        django.project(env.project_path_name)
        from django.conf import settings

        return settings

    def check_database_engine(self, settings):
        engine = settings.DATABASES['default']['ENGINE']

        if engine != 'django.db.backends.postgresql_psycopg2':
            raise Exception('Only supports postgres database')


class InstallWheels(Task):
    """ REMO - Build wheels """
    name = 'install_wheels'

    def __init__(self, *args, **kwargs):
        self.skip_packages = kwargs.pop('skip_packages', [])

        super(InstallWheels, self).__init__(*args, **kwargs)

    def run(self):
        website_user = env.user
        env.user = 'leukeleu'

        with settings(hide('warnings', 'running', 'stdout', 'stderr')):
            temp_wheels_dir = "/tmp/%s" % uuid.uuid4().hex
            try:
                requirements_file = os.path.join(temp_wheels_dir, 'requirements.txt')

                run('mkdir %s' % temp_wheels_dir)
                put('requirements.txt', requirements_file)
                run('pip wheel --wheel-dir=%s -r %s' % (temp_wheels_dir, requirements_file))

                # Copy wheel files, except wheels from skip_packages option
                wheel_files = ls(os.path.join(temp_wheels_dir, '*.whl'))
                for wheel_file in wheel_files:
                    wheel_base_name = os.path.basename(wheel_file)
                    if self.must_include_file(wheel_base_name):
                        if not exists(os.path.join('/opt/wheels/', wheel_base_name)):
                            print wheel_base_name
                            run('cp %s /opt/wheels' % os.path.join(temp_wheels_dir, wheel_file))
            finally:
                run("rm -rf %s" % temp_wheels_dir)
                env.user = website_user

    def must_include_file(self, wheel_file):
        for skip_package in self.skip_packages:
            if wheel_file.startswith('%s-' % skip_package):
                return False
        return True
